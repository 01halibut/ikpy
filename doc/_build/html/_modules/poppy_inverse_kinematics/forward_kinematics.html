

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>poppy_inverse_kinematics.forward_kinematics &mdash; poppy-inverse-kinematics 1.0.2 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="poppy-inverse-kinematics 1.0.2 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> poppy-inverse-kinematics
          

          
          </a>

          
            
            
              <div class="version">
                1.0.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="simple">
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">poppy-inverse-kinematics</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>poppy_inverse_kinematics.forward_kinematics</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for poppy_inverse_kinematics.forward_kinematics</h1><div class="highlight"><pre>
<span class="c"># coding: utf8</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">sympy</span>


<div class="viewcode-block" id="euler_from_unit_vector"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.euler_from_unit_vector">[docs]</a><span class="k">def</span> <span class="nf">euler_from_unit_vector</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Retourne les angles d&#39;euler associés à un vecteur unitaire&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">(</span><span class="n">y</span> <span class="o">/</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
    <span class="k">return</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="euler_from_URDF_parameters"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.euler_from_URDF_parameters">[docs]</a><span class="k">def</span> <span class="nf">euler_from_URDF_parameters</span><span class="p">(</span><span class="n">URDF_parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts URDF_parameters to euler_parameters&quot;&quot;&quot;</span>
    <span class="n">euler_parameters</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">absolute_rotations</span> <span class="o">=</span> <span class="p">[</span><span class="n">param</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">URDF_parameters</span><span class="p">]</span>
    <span class="n">relative_euler_rotations</span> <span class="o">=</span> <span class="n">get_relative_angles</span><span class="p">(</span><span class="n">absolute_rotations</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">URDF_parameters</span><span class="p">):</span>
        <span class="n">euler_parameters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">((</span><span class="n">relative_euler_rotations</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">relative_euler_rotations</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span> <span class="n">y</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">euler_parameters</span>

</div>
<div class="viewcode-block" id="get_relative_angles"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.get_relative_angles">[docs]</a><span class="k">def</span> <span class="nf">get_relative_angles</span><span class="p">(</span><span class="n">absolute_vectors</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert a list of absolute_vectors to a list of vectors relative to the frame oriented by the previous in the list&quot;&quot;&quot;</span>
    <span class="n">angles_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">absolute_vector</span> <span class="ow">in</span> <span class="n">absolute_vectors</span><span class="p">:</span>
        <span class="n">relative_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">frame_matrix</span><span class="p">),</span> <span class="n">absolute_vector</span><span class="p">)</span>
        <span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">)</span> <span class="o">=</span> <span class="n">euler_from_unit_vector</span><span class="p">(</span><span class="o">*</span><span class="n">relative_vector</span><span class="p">)</span>
        <span class="n">angles_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">))</span>
        <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">frame_matrix</span><span class="p">,</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">angles_list</span>

</div>
<div class="viewcode-block" id="get_robot_length"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.get_robot_length">[docs]</a><span class="k">def</span> <span class="nf">get_robot_length</span><span class="p">(</span><span class="n">robot_parameters</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calcul la longueur du robot (tendu)&quot;&quot;&quot;</span>
    <span class="n">translations_vectors</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">robot_parameters</span><span class="p">]</span>
    <span class="n">joints_lengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vector</span><span class="p">]))</span>
                      <span class="k">for</span> <span class="n">vector</span> <span class="ow">in</span> <span class="n">translations_vectors</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">joints_lengths</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="cartesian_to_homogeneous"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.cartesian_to_homogeneous">[docs]</a><span class="k">def</span> <span class="nf">cartesian_to_homogeneous</span><span class="p">(</span><span class="n">cartesian_matrix</span><span class="p">,</span> <span class="n">matrix_type</span><span class="o">=</span><span class="s">&quot;numpy&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts a cartesian matrix to an homogenous matrix&quot;&quot;&quot;</span>
    <span class="n">dimension_x</span><span class="p">,</span> <span class="n">dimension_y</span> <span class="o">=</span> <span class="n">cartesian_matrix</span><span class="o">.</span><span class="n">shape</span>
    <span class="c"># Square matrix</span>
    <span class="c"># Manage different types fo input matrixes</span>
    <span class="k">if</span> <span class="n">matrix_type</span> <span class="o">==</span> <span class="s">&quot;numpy&quot;</span><span class="p">:</span>
        <span class="n">homogeneous_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimension_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">matrix_type</span> <span class="o">==</span> <span class="s">&quot;sympy&quot;</span><span class="p">:</span>
        <span class="n">homogeneous_matrix</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">dimension_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c"># Add a column filled with 0 and finishing with 1 to the cartesian matrix to transform it into an homogeneous one</span>
    <span class="n">homogeneous_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cartesian_matrix</span>

    <span class="k">return</span> <span class="n">homogeneous_matrix</span>

</div>
<div class="viewcode-block" id="cartesian_to_homogeneous_vectors"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.cartesian_to_homogeneous_vectors">[docs]</a><span class="k">def</span> <span class="nf">cartesian_to_homogeneous_vectors</span><span class="p">(</span><span class="n">cartesian_vector</span><span class="p">,</span> <span class="n">matrix_type</span><span class="o">=</span><span class="s">&quot;numpy&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts a cartesian vector to an homogenous vector&quot;&quot;&quot;</span>
    <span class="n">dimension_x</span> <span class="o">=</span> <span class="n">cartesian_vector</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c"># Vector</span>
    <span class="k">if</span> <span class="n">matrix_type</span> <span class="o">==</span> <span class="s">&quot;numpy&quot;</span><span class="p">:</span>
        <span class="n">homogeneous_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">dimension_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c"># Last item is a 1</span>
        <span class="n">homogeneous_vector</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">homogeneous_vector</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cartesian_vector</span>
    <span class="k">return</span> <span class="n">homogeneous_vector</span>

</div>
<div class="viewcode-block" id="homogeneous_to_cartesian_vectors"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.homogeneous_to_cartesian_vectors">[docs]</a><span class="k">def</span> <span class="nf">homogeneous_to_cartesian_vectors</span><span class="p">(</span><span class="n">homogeneous_vector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Converts a cartesian vector to an homogenous vector&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">homogeneous_vector</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="homogeneous_to_cartesian"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.homogeneous_to_cartesian">[docs]</a><span class="k">def</span> <span class="nf">homogeneous_to_cartesian</span><span class="p">(</span><span class="n">homogeneous_matrix</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converts a cartesian vector to an homogenous matrix&quot;&quot;&quot;</span>
    <span class="c"># Remove the last column</span>
    <span class="k">return</span> <span class="n">homogeneous_matrix</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="homogeneous_transformation"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.homogeneous_transformation">[docs]</a><span class="k">def</span> <span class="nf">homogeneous_transformation</span><span class="p">(</span><span class="n">homogeneous_matrix</span><span class="p">,</span> <span class="n">cartesian_vector</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the cartesian coordinates of the transformation_matrix applied to the input vector&quot;&quot;&quot;</span>
    <span class="n">cartesian_pos</span> <span class="o">=</span> <span class="n">homogeneous_to_cartesian_vectors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">homogeneous_matrix</span><span class="p">,</span> <span class="n">cartesian_to_homogeneous_vectors</span><span class="p">(</span><span class="n">cartesian_vector</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">cartesian_pos</span>

</div>
<div class="viewcode-block" id="Rx_matrix"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.Rx_matrix">[docs]</a><span class="k">def</span> <span class="nf">Rx_matrix</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rotation matrix around the X axis&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)]</span>
    <span class="p">])</span>

</div>
<div class="viewcode-block" id="Rz_matrix"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.Rz_matrix">[docs]</a><span class="k">def</span> <span class="nf">Rz_matrix</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rotation matrix around the Z axis&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">])</span>

</div>
<div class="viewcode-block" id="symbolic_Rz_matrix"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.symbolic_Rz_matrix">[docs]</a><span class="k">def</span> <span class="nf">symbolic_Rz_matrix</span><span class="p">(</span><span class="n">symbolic_theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Matrice symbolique de rotation autour de l&#39;axe Z&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span>
        <span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">symbolic_theta</span><span class="p">),</span> <span class="o">-</span><span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">symbolic_theta</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">symbolic_theta</span><span class="p">),</span> <span class="n">sympy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">symbolic_theta</span><span class="p">),</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">])</span>

</div>
<div class="viewcode-block" id="Ry_matrix"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.Ry_matrix">[docs]</a><span class="k">def</span> <span class="nf">Ry_matrix</span><span class="p">(</span><span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Rotation matrix around the Y axis&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)]</span>
    <span class="p">])</span>

</div>
<div class="viewcode-block" id="rotation_matrix"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.rotation_matrix">[docs]</a><span class="k">def</span> <span class="nf">rotation_matrix</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">psi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Retourne la matrice de rotation décrite par les angles d&#39;Euler donnés en paramètres&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Rz_matrix</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Rx_matrix</span><span class="p">(</span><span class="n">theta</span><span class="p">),</span> <span class="n">Rz_matrix</span><span class="p">(</span><span class="n">psi</span><span class="p">)))</span>

</div>
<div class="viewcode-block" id="symbolic_rotation_matrix"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.symbolic_rotation_matrix">[docs]</a><span class="k">def</span> <span class="nf">symbolic_rotation_matrix</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">symbolic_psi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Retourne une matrice de rotation où psi est symbolique&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">Rz_matrix</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span> <span class="o">*</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">Rx_matrix</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="o">*</span> <span class="n">symbolic_Rz_matrix</span><span class="p">(</span><span class="n">symbolic_psi</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="homogeneous_translation_matrix"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.homogeneous_translation_matrix">[docs]</a><span class="k">def</span> <span class="nf">homogeneous_translation_matrix</span><span class="p">(</span><span class="n">trans_x</span><span class="p">,</span> <span class="n">trans_y</span><span class="p">,</span> <span class="n">trans_z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a translation matrix the homogeneous space&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trans_x</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">trans_y</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">trans_z</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>

</div>
<div class="viewcode-block" id="axis_rotation_matrix"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.axis_rotation_matrix">[docs]</a><span class="k">def</span> <span class="nf">axis_rotation_matrix</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a translation matrix around the given axis&quot;&quot;&quot;</span>
    <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">z</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">s</span><span class="p">],</span>
        <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">z</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">s</span><span class="p">],</span>
        <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">]</span>
    <span class="p">])</span>

</div>
<div class="viewcode-block" id="symbolic_axis_rotation_matrix"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.symbolic_axis_rotation_matrix">[docs]</a><span class="k">def</span> <span class="nf">symbolic_axis_rotation_matrix</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">symbolic_theta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a translation matrix around the given axis&quot;&quot;&quot;</span>
    <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">]</span> <span class="o">=</span> <span class="n">axis</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">symbolic_theta</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">symbolic_theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">([</span>
        <span class="p">[</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">z</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="n">x</span> <span class="o">*</span> <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">s</span><span class="p">],</span>
        <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">z</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">s</span><span class="p">],</span>
        <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="n">y</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">c</span><span class="p">]</span>
    <span class="p">])</span>

</div>
<div class="viewcode-block" id="rpy_matrix"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.rpy_matrix">[docs]</a><span class="k">def</span> <span class="nf">rpy_matrix</span><span class="p">(</span><span class="n">roll</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">yaw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a rotation matrix described by the extrinsinc roll, pitch, yaw coordinates&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Rz_matrix</span><span class="p">(</span><span class="n">yaw</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Ry_matrix</span><span class="p">(</span><span class="n">pitch</span><span class="p">),</span> <span class="n">Rx_matrix</span><span class="p">(</span><span class="n">roll</span><span class="p">)))</span>

</div>
<div class="viewcode-block" id="symbolic_rpy_matrix"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.symbolic_rpy_matrix">[docs]</a><span class="k">def</span> <span class="nf">symbolic_rpy_matrix</span><span class="p">(</span><span class="n">roll</span><span class="p">,</span> <span class="n">pitch</span><span class="p">,</span> <span class="n">symbolic_yaw</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a symbolic rotation matrix described by the extrinsinc roll, pitch and symbolic yaw coordinates&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">symbolic_Rz_matrix</span><span class="p">(</span><span class="n">symbolic_yaw</span><span class="p">)</span> <span class="o">*</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">Ry_matrix</span><span class="p">(</span><span class="n">pitch</span><span class="p">))</span> <span class="o">*</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">Rx_matrix</span><span class="p">(</span><span class="n">roll</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="FK_jacobian"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.FK_jacobian">[docs]</a><span class="k">def</span> <span class="nf">FK_jacobian</span><span class="p">(</span><span class="n">robot_parameters</span><span class="p">,</span> <span class="n">nodes_angles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Retourne le jacobien de la FK&quot;&quot;&quot;</span>
    <span class="k">pass</span>

</div>
<div class="viewcode-block" id="get_nodes"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.get_nodes">[docs]</a><span class="k">def</span> <span class="nf">get_nodes</span><span class="p">(</span><span class="n">robot_parameters</span><span class="p">,</span> <span class="n">nodes_angles</span><span class="p">,</span> <span class="n">representation</span><span class="o">=</span><span class="s">&quot;euler&quot;</span><span class="p">,</span> <span class="n">model_type</span><span class="o">=</span><span class="s">&quot;custom&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Renvoie la liste des position des noeuds du robot, à partir de ses paramètres, et de la liste des angles</span>
<span class="sd">    La liste a len(robot_parameters) + 1 éléments et commence par (0,0,0)&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;custom&quot;</span><span class="p">:</span>
        <span class="n">full_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="p">((</span><span class="n">trans</span><span class="p">,</span> <span class="n">rot</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">robot_parameters</span><span class="p">,</span> <span class="n">nodes_angles</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;URDF&quot;</span><span class="p">:</span>
        <span class="n">full_list</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="p">((</span><span class="n">trans</span><span class="p">,</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">rotation</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">robot_parameters</span><span class="p">,</span> <span class="n">nodes_angles</span><span class="p">)</span>
        <span class="p">]</span>

    <span class="c">#  Initialisations</span>
    <span class="c"># Liste des positions des noeuds</span>
    <span class="n">pos_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">pos_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
    <span class="c"># Initiailisation de la matrice de changement de base</span>
    <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="c"># Liste des axes de rotation de chaque noeud</span>
    <span class="n">rotation_axe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">rotation_axes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c"># Origin rotation axe (virtual)</span>
    <span class="n">rotation_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]))</span>

    <span class="c"># Calcul des positions de chaque noeud</span>
    <span class="c"># print(representation, full_list)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">params</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">full_list</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;custom&quot;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">translation_vector</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span> <span class="o">=</span> <span class="n">params</span>
        <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;URDF&quot;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">translation_vector</span><span class="p">,</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">rot</span><span class="p">,</span> <span class="n">psi</span><span class="p">)</span> <span class="o">=</span> <span class="n">params</span>

        <span class="n">pos_index</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">pos_list</span><span class="p">[</span><span class="n">pos_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c"># Calcul de la position du noeud actuel</span>
        <span class="n">pos_relat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">translation_vector</span><span class="p">)</span>

        <span class="n">pos_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">frame_matrix</span><span class="p">,</span> <span class="n">pos_relat</span><span class="p">)</span> <span class="o">+</span> <span class="n">origin</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;URDF&quot;</span><span class="p">:</span>
            <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">frame_matrix</span><span class="p">,</span> <span class="n">axis_rotation_matrix</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">psi</span><span class="p">))</span>
            <span class="c"># pos_relat = np.dot(axis_rotation_matrix(rot, psi), pos_relat)</span>



        <span class="n">joint_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">translation_vector</span><span class="p">]))</span>

        <span class="c"># Calcul des coordonnées de l&#39;axe de rotation</span>
        <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;custom&quot;</span><span class="p">:</span>
            <span class="c"># En custom, l&#39;axe de rotation relatif est confondu avec [0, 0, 1]</span>
            <span class="n">relative_rotation_axe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">rotation_axe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">frame_matrix</span><span class="p">,</span> <span class="n">relative_rotation_axe</span> <span class="o">*</span> <span class="n">joint_length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">representation</span> <span class="o">==</span> <span class="s">&quot;euler&quot;</span><span class="p">:</span>
                <span class="c"># Calcul de la nouvelle matrice de rotation</span>
                <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">frame_matrix</span><span class="p">,</span> <span class="n">rotation_matrix</span><span class="p">(</span><span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rot</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">psi</span><span class="p">))</span>
                <span class="c"># print(index, frame_matrix)</span>

        <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;URDF&quot;</span><span class="p">:</span>
            <span class="c"># En URDF, l&#39;axe de rotation relatif est donné par rot</span>
            <span class="n">relative_rotation_axe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rot</span><span class="p">)</span>
            <span class="n">rotation_axe</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">frame_matrix</span><span class="p">,</span> <span class="n">relative_rotation_axe</span> <span class="o">*</span> <span class="n">joint_length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">representation</span> <span class="o">==</span> <span class="s">&quot;rpy&quot;</span><span class="p">:</span>
                <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">frame_matrix</span><span class="p">,</span> <span class="n">rpy_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">orientation</span><span class="p">))</span>

        <span class="n">rotation_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotation_axe</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span><span class="s">&quot;positions&quot;</span><span class="p">:</span> <span class="n">pos_list</span><span class="p">,</span> <span class="s">&quot;rotation_axes&quot;</span><span class="p">:</span> <span class="n">rotation_axes</span><span class="p">}</span>

</div>
<div class="viewcode-block" id="compute_transformation_symbolic"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.compute_transformation_symbolic">[docs]</a><span class="k">def</span> <span class="nf">compute_transformation_symbolic</span><span class="p">(</span><span class="n">robot_parameters</span><span class="p">,</span> <span class="n">representation</span><span class="o">=</span><span class="s">&quot;euler&quot;</span><span class="p">,</span> <span class="n">model_type</span><span class="o">=</span><span class="s">&quot;custom&quot;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Retourne la matrice de la forward_kinematic&quot;&quot;&quot;</span>

    <span class="c"># Initial value of the frame matrix in homogeneous coordinates</span>
    <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">joint_angles</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># Calcul itératif de la matrice de le FK</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">params</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">robot_parameters</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;custom&quot;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">translation_vector</span><span class="p">,</span> <span class="n">rot</span><span class="p">)</span> <span class="o">=</span> <span class="n">params</span>
        <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;URDF&quot;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">translation_vector</span><span class="p">,</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">rot</span><span class="p">)</span> <span class="o">=</span> <span class="n">params</span>

        <span class="c"># Angle symbolique qui paramètre la rotation du joint en cours</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&quot;psi_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="n">joint_angles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span>

        <span class="c"># Apply translation matrix</span>
        <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">frame_matrix</span> <span class="o">*</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">homogeneous_translation_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">translation_vector</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;URDF&quot;</span><span class="p">:</span>
            <span class="c"># Apply rotation matrix</span>
            <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">frame_matrix</span> <span class="o">*</span> <span class="n">cartesian_to_homogeneous</span><span class="p">(</span><span class="n">symbolic_axis_rotation_matrix</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">psi</span><span class="p">),</span> <span class="n">matrix_type</span><span class="o">=</span><span class="s">&quot;sympy&quot;</span><span class="p">)</span>

        <span class="c"># Apply orientation matrix</span>
        <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;custom&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">representation</span> <span class="o">==</span> <span class="s">&quot;euler&quot;</span><span class="p">:</span>
                <span class="c"># Calcul de la nouvelle matrice de rotation</span>
                <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">frame_matrix</span> <span class="o">*</span> <span class="n">cartesian_to_homogeneous</span><span class="p">(</span><span class="n">symbolic_rotation_matrix</span><span class="p">(</span><span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rot</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">psi</span><span class="p">),</span> <span class="n">matrix_type</span><span class="o">=</span><span class="s">&quot;sympy&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;URDF&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">representation</span> <span class="o">==</span> <span class="s">&quot;rpy&quot;</span><span class="p">:</span>
                <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">frame_matrix</span> <span class="o">*</span> <span class="n">cartesian_to_homogeneous</span><span class="p">(</span><span class="n">rpy_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">orientation</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
        <span class="c"># Simplify the matrix</span>
        <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">frame_matrix</span><span class="p">)</span>

    <span class="c"># On retourne une fonction lambda de la FK</span>
    <span class="k">return</span> <span class="n">sympy</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">joint_angles</span><span class="p">,</span> <span class="n">frame_matrix</span><span class="p">,</span> <span class="n">dummify</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">use_imps</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="get_end_effector_symbolic"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.get_end_effector_symbolic">[docs]</a><span class="k">def</span> <span class="nf">get_end_effector_symbolic</span><span class="p">(</span><span class="n">symbolic_transformation_matrix</span><span class="p">,</span> <span class="n">nodes_angles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Renvoie la position du end effector en fonction de la configuration des joints&quot;&quot;&quot;</span>
    <span class="c"># On applique la matrice transformation au vecteur [0, 0, 0]</span>
    <span class="k">return</span> <span class="n">homogeneous_transformation</span><span class="p">(</span><span class="n">symbolic_transformation_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">nodes_angles</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>

</div>
<div class="viewcode-block" id="compute_transformation_hybrid"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.compute_transformation_hybrid">[docs]</a><span class="k">def</span> <span class="nf">compute_transformation_hybrid</span><span class="p">(</span><span class="n">robot_parameters</span><span class="p">,</span> <span class="n">representation</span><span class="o">=</span><span class="s">&quot;euler&quot;</span><span class="p">,</span> <span class="n">model_type</span><span class="o">=</span><span class="s">&quot;custom&quot;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the list of transformation matrixes for each joint&quot;&quot;&quot;</span>

    <span class="n">joint_matrixes</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c"># Calcul itératif de la matrice de le FK</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">params</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">robot_parameters</span><span class="p">):</span>
        <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;custom&quot;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">translation_vector</span><span class="p">,</span> <span class="n">rot</span><span class="p">)</span> <span class="o">=</span> <span class="n">params</span>
        <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;URDF&quot;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">translation_vector</span><span class="p">,</span> <span class="n">orientation</span><span class="p">,</span> <span class="n">rot</span><span class="p">)</span> <span class="o">=</span> <span class="n">params</span>

        <span class="c"># Angle symbolique qui paramètre la rotation du joint en cours</span>
        <span class="n">psi</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">symbols</span><span class="p">(</span><span class="s">&quot;psi_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>

        <span class="c"># Apply translation matrix</span>
        <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">frame_matrix</span> <span class="o">*</span> <span class="n">sympy</span><span class="o">.</span><span class="n">Matrix</span><span class="p">(</span><span class="n">homogeneous_translation_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">translation_vector</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;URDF&quot;</span><span class="p">:</span>
            <span class="c"># Apply rotation matrix</span>
            <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">frame_matrix</span> <span class="o">*</span> <span class="n">cartesian_to_homogeneous</span><span class="p">(</span><span class="n">symbolic_axis_rotation_matrix</span><span class="p">(</span><span class="n">rot</span><span class="p">,</span> <span class="n">psi</span><span class="p">),</span> <span class="n">matrix_type</span><span class="o">=</span><span class="s">&quot;sympy&quot;</span><span class="p">)</span>

        <span class="c"># Apply orientation matrix</span>
        <span class="k">if</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;custom&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">representation</span> <span class="o">==</span> <span class="s">&quot;euler&quot;</span><span class="p">:</span>
                <span class="c"># Calcul de la nouvelle matrice de rotation</span>
                <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">frame_matrix</span> <span class="o">*</span> <span class="n">cartesian_to_homogeneous</span><span class="p">(</span><span class="n">symbolic_rotation_matrix</span><span class="p">(</span><span class="n">rot</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rot</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">psi</span><span class="p">),</span> <span class="n">matrix_type</span><span class="o">=</span><span class="s">&quot;sympy&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">model_type</span> <span class="o">==</span> <span class="s">&quot;URDF&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">representation</span> <span class="o">==</span> <span class="s">&quot;rpy&quot;</span><span class="p">:</span>
                <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">frame_matrix</span> <span class="o">*</span> <span class="n">cartesian_to_homogeneous</span><span class="p">(</span><span class="n">rpy_matrix</span><span class="p">(</span><span class="o">*</span><span class="n">orientation</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">simplify</span><span class="p">:</span>
            <span class="c"># Simplify the matrix</span>
            <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">sympy</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">frame_matrix</span><span class="p">)</span>

        <span class="c"># Save the joint transformation_matrix</span>
        <span class="n">joint_matrixes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sympy</span><span class="o">.</span><span class="n">lambdify</span><span class="p">(</span><span class="n">psi</span><span class="p">,</span> <span class="n">frame_matrix</span><span class="p">,</span> <span class="s">&quot;numpy&quot;</span><span class="p">,</span> <span class="n">dummify</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">use_imps</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>

    <span class="c"># On retourne une fonction lambda de la FK</span>
    <span class="k">return</span> <span class="n">joint_matrixes</span>

</div>
<div class="viewcode-block" id="get_end_effector_hybrid"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.get_end_effector_hybrid">[docs]</a><span class="k">def</span> <span class="nf">get_end_effector_hybrid</span><span class="p">(</span><span class="n">symbolic_transformation_matrixes</span><span class="p">,</span> <span class="n">nodes_angles</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Renvoie la position du end effector en fonction de la configuration des joints&quot;&quot;&quot;</span>
    <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">joint_matrix</span><span class="p">,</span> <span class="n">joint_angle</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">symbolic_transformation_matrixes</span><span class="p">,</span> <span class="n">nodes_angles</span><span class="p">)):</span>
        <span class="c"># Compute iteratively the position</span>
        <span class="n">frame_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">frame_matrix</span><span class="p">,</span> <span class="n">joint_matrix</span><span class="p">(</span><span class="n">joint_angle</span><span class="p">))</span>
    <span class="c"># Return the matrix origin</span>
    <span class="k">return</span> <span class="n">homogeneous_to_cartesian_vectors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">frame_matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])))</span>

</div>
<div class="viewcode-block" id="compute_transformation"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.compute_transformation">[docs]</a><span class="k">def</span> <span class="nf">compute_transformation</span><span class="p">(</span><span class="n">robot_parameters</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&quot;default&quot;</span><span class="p">,</span> <span class="n">representation</span><span class="o">=</span><span class="s">&quot;euler&quot;</span><span class="p">,</span> <span class="n">model_type</span><span class="o">=</span><span class="s">&quot;custom&quot;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes a transformation and returns an object depending of the selected method&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;symbolic&quot;</span><span class="p">:</span>
        <span class="c"># Symbolic method</span>
        <span class="k">return</span> <span class="n">compute_transformation_symbolic</span><span class="p">(</span><span class="n">robot_parameters</span><span class="p">,</span> <span class="n">representation</span><span class="o">=</span><span class="n">representation</span><span class="p">,</span> <span class="n">model_type</span><span class="o">=</span><span class="n">model_type</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;hybrid&quot;</span><span class="p">:</span>
        <span class="c"># Hybrid method</span>
        <span class="k">return</span> <span class="n">compute_transformation_hybrid</span><span class="p">(</span><span class="n">robot_parameters</span><span class="p">,</span> <span class="n">representation</span><span class="o">=</span><span class="n">representation</span><span class="p">,</span> <span class="n">model_type</span><span class="o">=</span><span class="n">model_type</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="n">simplify</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Default</span>
        <span class="k">return</span> <span class="bp">None</span>

</div>
<div class="viewcode-block" id="get_end_effector"><a class="viewcode-back" href="../../poppy_inverse_kinematics.html#poppy_inverse_kinematics.forward_kinematics.get_end_effector">[docs]</a><span class="k">def</span> <span class="nf">get_end_effector</span><span class="p">(</span><span class="n">nodes_angles</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&quot;default&quot;</span><span class="p">,</span> <span class="n">transformation_lambda</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the a position of the end-effoctor, computed with the selected method&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;hybrid&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">get_end_effector_hybrid</span><span class="p">(</span><span class="n">transformation_lambda</span><span class="p">,</span> <span class="n">nodes_angles</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s">&quot;symbolic&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">get_end_effector_symbolic</span><span class="p">(</span><span class="n">transformation_lambda</span><span class="p">,</span> <span class="n">nodes_angles</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Default method</span>
        <span class="k">return</span> <span class="n">get_nodes</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&quot;robot_parameters&quot;</span><span class="p">],</span> <span class="n">nodes_angles</span><span class="p">,</span> <span class="n">representation</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&quot;representation&quot;</span><span class="p">],</span> <span class="n">model_type</span><span class="o">=</span><span class="n">kwargs</span><span class="p">[</span><span class="s">&quot;model_type&quot;</span><span class="p">])[</span><span class="s">&quot;positions&quot;</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, Pierre Manceron.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>